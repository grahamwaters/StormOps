<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Atmospheric Cloud Simulator</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;700&display=swap');

        body {
            font-family: 'Roboto', sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            margin: 0;
            padding: 20px;
            background-color: #000033; /* Navy Blue background for page */
            color: #e0e0e0;
            min-height: 100vh;
            box-sizing: border-box;
            transition: padding 0.3s ease;
        }

        body.fullscreen-active {
            padding: 0;
            overflow: hidden;
        }

        header, #controls-container {
            width: 100%;
            max-width: 700px;
            text-align: center;
            margin-bottom: 20px;
            transition: opacity 0.3s ease, transform 0.3s ease, visibility 0.3s ease;
            visibility: visible;
            opacity: 1;
            transform: translateY(0);
        }

        body.fullscreen-active header,
        body.fullscreen-active #controls-container {
            opacity: 0;
            transform: translateY(-20px);
            visibility: hidden;
            pointer-events: none;
        }

        header h1 {
            font-weight: 300;
            font-size: 2.5em;
            color: #66aaff; /* Lighter blue for title */
            margin-bottom: 10px;
        }

        #controls {
            background-color: #00004d; /* Darker Navy for controls */
            padding: 25px 30px;
            border-radius: 12px;
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.5);
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 15px;
            width: 100%;
            max-width: 500px;
            box-sizing: border-box;
            margin: 0 auto;
        }

        .file-input-wrapper {
            position: relative; /* Establishes stacking context */
            overflow: hidden;
            display: inline-block;
            padding: 10px 20px;
            font-size: 0.9em;
            background-color: #0055cc;
            color: white;
            border-radius: 8px;
            cursor: pointer;
            transition: background-color 0.3s ease;
            font-weight: 400;
            width: auto;
            text-align: center;
            z-index: 1; /* Explicitly set stacking order */
        }
        .file-input-wrapper:hover {
            background-color: #0044aa;
        }
        .file-input-wrapper input[type="file"] {
            position: absolute;
            left: 0;
            top: 0;
            opacity: 0;
            font-size: 100px;
            cursor: pointer;
            width: 100%;
            height: 100%;
        }


        #fileName {
            font-size: 0.9em;
            color: #aaa;
            margin-top: 5px;
            display: block;
            text-align: center;
            min-height: 1.2em;
        }

        .button-group {
            display: flex;
            gap: 10px;
            position: relative; /* Important for z-index to take effect */
            z-index: 2;         /* Higher z-index to be on top */
        }

        #processButton, #saveSimButton {
            padding: 10px 25px;
            font-size: 1em;
            font-weight: 700;
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: background-color 0.3s ease, transform 0.1s ease;
        }
        #processButton { background-color: #28a745; }
        #processButton:hover { background-color: #1e7e34; }
        #saveSimButton { background-color: #ff8c00; display: none; /* Hidden initially */ }
        #saveSimButton:hover { background-color: #cc7000; }

        #processButton:active, #saveSimButton:active { transform: scale(0.98); }
        #processButton:disabled, #saveSimButton:disabled { background-color: #555; color: #888; cursor: not-allowed; }


        #particleCanvas {
            border: 1px solid #00001a; /* Very dark navy border */
            background-color: #000026; /* Navy Blue for Canvas */
            margin-top: 0;
            box-shadow: 0 0 20px rgba(102,170,255,0.15);
            display: block;
            transition: width 0.3s ease, height 0.3s ease;
        }

        body.fullscreen-active #particleCanvas {
            position: fixed; top: 0; left: 0;
            width: 100vw !important; height: 100vh !important;
            border: none; box-shadow: none; z-index: 1000; margin-top:0;
        }

        #statusMessage {
            color: #66aaff; font-size: 1em; min-height: 1.5em;
            text-align: center; margin-top: 10px; position: relative;
        }
        body.fullscreen-active #statusMessage {
            position: fixed; bottom: 20px; left: 50%;
            transform: translateX(-50%); background-color: rgba(0,0,26,0.7); /* Navy transparent */
            padding: 5px 10px; border-radius: 5px; z-index: 1001;
        }

        #backButton {
            position: fixed;
            top: 20px;
            left: 20px;
            background-color: rgba(0, 85, 204, 0.7);
            color: white;
            border: none;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            font-size: 20px;
            line-height: 40px; /* Vertically center arrow */
            text-align: center; /* Horizontally center arrow */
            cursor: pointer;
            z-index: 1002;
            display: none;
            /* display: flex; align-items: center; justify-content: center; */ /* Alternative centering if needed */
            box-shadow: 0 2px 5px rgba(0,0,0,0.3);
        }
        #backButton:hover {
            background-color: rgba(0, 68, 170, 0.9);
        }

         @media (min-width: 600px) {
            #controls { flex-direction: row; justify-content: center; }
        }
    </style>
</head>
<body>
    <header>
        <h1>Atmospheric Cloud Simulator</h1>
    </header>

    <div id="controls-container">
        <div id="controls">
            <label class="file-input-wrapper">
                Select Image
                <input type="file" id="imageFile" accept="image/*">
            </label>
            <div class="button-group">
                <button id="processButton" disabled>Simulate Clouds</button>
                <button id="saveSimButton" disabled>Save Simulation</button>
            </div>
        </div>
        <span id="fileName">No file selected.</span>
        <div id="statusMessage"></div>
    </div>
    <button id="backButton" title="Exit Fullscreen (Esc)">&larr;</button>
    <canvas id="particleCanvas"></canvas>

    <script>
        // Get references to DOM elements
        const imageFileInput = document.getElementById('imageFile');
        const processButton = document.getElementById('processButton');
        const saveSimButton = document.getElementById('saveSimButton');
        const particleCanvas = document.getElementById('particleCanvas');
        const statusMessage = document.getElementById('statusMessage');
        const fileNameDisplay = document.getElementById('fileName');
        const controlsContainer = document.getElementById('controls-container'); // Used for hiding controls in fullscreen
        const headerElement = document.querySelector('header'); // Used for hiding header in fullscreen
        const bodyElement = document.body;
        const backButton = document.getElementById('backButton');
        const ctx = particleCanvas.getContext('2d');

        // Global variables for simulation state
        let particles = []; // Array to hold active particles
        let particleInitialData = []; // Array to hold initial data for saving/recreating simulation
        let sourceImage = null; // Holds the loaded image object
        let sourceImageName = 'simulation'; // Default name for saved simulation
        let animationFrameId = null; // ID for the animation loop
        let isFullscreen = false; // Flag for fullscreen mode
        let originalCanvasWidth, originalCanvasHeight; // Store original canvas dimensions

        // Particle color definitions
        const PARTICLE_COLORS = {
            CLOUD: '255, 255, 255', // White for general clouds
            OVERSHOOT: '255, 165, 0' // Orange for brighter/overshooting tops
        };

        // Particle class definition
        class Particle {
            constructor(params) { // Constructor takes a parameter object
                this.initialX = params.x; // Initial X position (from image)
                this.initialY = params.y; // Initial Y position (from image)
                this.x = params.x + (Math.random() - 0.5) * 5; // Current X, slight random offset
                this.y = params.y + (Math.random() - 0.5) * 5; // Current Y, slight random offset
                this.size = params.size || (Math.random() * 2.5 + 1.5); // Particle size, with default randomization

                // Opacity target based on image brightness, clamped between 0.05 and 0.7
                this.targetOpacity = Math.min(0.7, Math.max(0.05, params.baseOpacityTarget));
                this.opacity = 0; // Start fully transparent for fade-in

                // Velocity components, with default randomization
                this.vx = params.vx || (Math.random() - 0.5) * 0.18;
                this.vy = params.vy || (Math.random() - 0.5) * 0.09;

                // Lifespan of the particle, with default randomization
                this.initialLife = params.initialLife || (Math.random() * 600 + 500); // Frames
                this.life = this.initialLife;

                this.color = params.color || PARTICLE_COLORS.CLOUD; // Particle color, defaults to CLOUD

                // Parameters for opacity pulsing effect
                this.opacityPulseSpeed = Math.random() * 0.003 + 0.001;
                this.opacityPulseDirection = 1;
                this.fadeInCompleteness = 0; // Tracks progress of initial fade-in
                this.fadeInDuration = 60; // Duration of fade-in in frames
            }

            update() {
                // Move particle
                this.x += this.vx;
                this.y += this.vy;
                this.life--; // Decrease lifespan

                // Handle fade-in effect
                if (this.fadeInCompleteness < 1) {
                    this.fadeInCompleteness += 1 / this.fadeInDuration;
                    this.opacity = this.targetOpacity * Math.min(1, this.fadeInCompleteness);
                } else {
                    // Handle fade-out at end of life or opacity pulsing
                    if (this.life < this.initialLife * 0.2) { // Start fading out when 20% life remains
                        this.opacity = this.targetOpacity * (this.life / (this.initialLife * 0.2));
                    } else { // Pulsing opacity
                        this.opacity += this.opacityPulseSpeed * this.opacityPulseDirection;
                        if (this.opacity > this.targetOpacity || this.opacity < this.targetOpacity * 0.4) {
                            this.opacityPulseDirection *= -1; // Reverse pulse direction
                        }
                    }
                }
                // Clamp opacity to valid range
                this.opacity = Math.max(0, Math.min(this.targetOpacity, this.opacity));

                // Wrap particles around canvas edges
                if (particleCanvas.width > 0) { // Check to prevent errors if canvas has no width
                    if (this.x > particleCanvas.width + this.size) this.x = -this.size;
                    if (this.x < -this.size) this.x = particleCanvas.width + this.size;
                    if (this.y > particleCanvas.height + this.size) this.y = -this.size;
                    if (this.y < -this.size) this.y = particleCanvas.height + this.size;
                }
            }

            draw() {
                // Don't draw if invisible or dead
                if (this.opacity <= 0.001 || this.life <= 0) return;

                ctx.beginPath();
                // Create a radial gradient for a soft particle effect
                const gradient = ctx.createRadialGradient(this.x, this.y, 0, this.x, this.y, this.size);
                gradient.addColorStop(0, `rgba(${this.color}, ${this.opacity * 0.9})`); // Center is more opaque
                gradient.addColorStop(0.4, `rgba(${this.color}, ${this.opacity * 0.6})`);
                gradient.addColorStop(1, `rgba(${this.color}, 0)`); // Edge is transparent
                ctx.fillStyle = gradient;
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2); // Draw particle as a circle
                ctx.fill();
            }
        }

        // Function to handle entering fullscreen simulation mode
        function enterFullscreenMode() {
            if (isFullscreen) return;
            isFullscreen = true;
            bodyElement.classList.add('fullscreen-active'); // Add class to body for CSS changes
            backButton.style.display = 'flex'; // Show back button (use flex for potential centering)
            saveSimButton.style.display = 'inline-block'; // Show save button
            saveSimButton.disabled = particleInitialData.length === 0; // Enable if data exists

            // Store original canvas size and set to fullscreen
            originalCanvasWidth = particleCanvas.width;
            originalCanvasHeight = particleCanvas.height;
            particleCanvas.width = window.innerWidth;
            particleCanvas.height = window.innerHeight;
            statusMessage.textContent = "Simulating... Press 'Esc' or Back Button to exit.";
        }

        // Function to handle exiting fullscreen simulation mode
        function exitFullscreenMode() {
            if (!isFullscreen) return;
            isFullscreen = false;
            bodyElement.classList.remove('fullscreen-active'); // Remove fullscreen class
            backButton.style.display = 'none'; // Hide back button
            saveSimButton.style.display = 'none'; // Hide save button

            // Stop animation and clear particles
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
                animationFrameId = null;
            }
            particles = [];
            particleInitialData = [];
            if (particleCanvas.width > 0 && particleCanvas.height > 0) { // Check before clearing
                 ctx.clearRect(0,0, particleCanvas.width, particleCanvas.height);
            }

            // Restore original canvas size or default if not set
            particleCanvas.width = originalCanvasWidth || defaultCanvasWidth;
            particleCanvas.height = originalCanvasHeight || defaultCanvasHeight;

            // Update UI elements
            processButton.disabled = imageFileInput.files.length === 0;
            statusMessage.textContent = 'Exited fullscreen. Select an image to simulate.';
            fileNameDisplay.textContent = imageFileInput.files.length > 0 ? imageFileInput.files[0].name : 'No file selected.';
        }


        // Function to analyze the image and create particles
        function analyzeImage(img) {
            statusMessage.textContent = isFullscreen ? "Analyzing... 'Esc' or Back to exit." : 'Simulating...';
            processButton.disabled = true; // Disable button during processing
            particles = []; // Clear existing particles
            particleInitialData = []; // Clear initial data

            // Use an offscreen canvas for image processing to avoid drawing to the main canvas
            const offscreenCanvas = document.createElement('canvas');
            const offscreenCtx = offscreenCanvas.getContext('2d', { willReadFrequently: true }); // Important for getImageData performance

            const canvasWidth = particleCanvas.width;
            const canvasHeight = particleCanvas.height;
            offscreenCanvas.width = canvasWidth;
            offscreenCanvas.height = canvasHeight;

            // Calculate dimensions to draw image while maintaining aspect ratio
            const imgAspectRatio = img.width / img.height;
            const canvasAspectRatio = canvasWidth / canvasHeight;
            let drawWidth, drawHeight, offsetX, offsetY;

            if (imgAspectRatio > canvasAspectRatio) { // Image is wider than canvas
                drawWidth = canvasWidth;
                drawHeight = drawWidth / imgAspectRatio;
                offsetX = 0;
                offsetY = (canvasHeight - drawHeight) / 2; // Center vertically
            } else { // Image is taller or same aspect ratio
                drawHeight = canvasHeight;
                drawWidth = drawHeight * imgAspectRatio;
                offsetY = 0;
                offsetX = (canvasWidth - drawWidth) / 2; // Center horizontally
            }

            offscreenCtx.fillStyle = 'rgba(0,0,0,0)'; // Ensure transparent background if image is smaller
            offscreenCtx.fillRect(0, 0, canvasWidth, canvasHeight);
            offscreenCtx.drawImage(img, offsetX, offsetY, drawWidth, drawHeight);

            try {
                const imageData = offscreenCtx.getImageData(0, 0, canvasWidth, canvasHeight);
                const data = imageData.data; // Pixel data array (R,G,B,A, R,G,B,A, ...)

                // Thresholds for identifying cloud-like pixels
                const OVERSHOOT_BRIGHTNESS_THRESHOLD = 245; // Very bright pixels
                const CLOUD_BRIGHTNESS_THRESHOLD = 175;    // Moderately bright pixels
                const samplingRate = isFullscreen ? 2 : 1; // Sample fewer pixels in fullscreen for performance

                // Iterate over image pixels
                for (let y = 0; y < canvasHeight; y += samplingRate) {
                    for (let x = 0; x < canvasWidth; x += samplingRate) {
                        const index = (y * canvasWidth + x) * 4; // Calculate index in pixel data array
                        const r = data[index];
                        const g = data[index + 1];
                        const b = data[index + 2];
                        const a = data[index + 3]; // Alpha value

                        if (a < 20) continue; // Skip nearly transparent pixels

                        const brightness = (r + g + b) / 3; // Average brightness
                        let particleColor = null;
                        let isCloud = false;

                        // Determine particle type based on brightness and color
                        if (r > OVERSHOOT_BRIGHTNESS_THRESHOLD && g > OVERSHOOT_BRIGHTNESS_THRESHOLD && b > OVERSHOOT_BRIGHTNESS_THRESHOLD && brightness > OVERSHOOT_BRIGHTNESS_THRESHOLD -5) {
                            particleColor = PARTICLE_COLORS.OVERSHOOT;
                            isCloud = true;
                        } else if (brightness > CLOUD_BRIGHTNESS_THRESHOLD && a > 70) { // Alpha check for semi-transparent clouds
                            particleColor = PARTICLE_COLORS.CLOUD;
                            isCloud = true;
                        }

                        if (isCloud) {
                            // Normalize brightness for particle density and opacity
                            const normalizedBrightness = (brightness - CLOUD_BRIGHTNESS_THRESHOLD) / (255 - CLOUD_BRIGHTNESS_THRESHOLD);
                            const numParticlesToSpawn = 1 + Math.floor(normalizedBrightness * 1.2); // Spawn more particles for brighter areas

                            for (let i = 0; i < numParticlesToSpawn; i++) {
                                const currentParticle = new Particle({
                                    x: x,
                                    y: y,
                                    baseOpacityTarget: normalizedBrightness * 0.35 + 0.05, // Opacity based on brightness
                                    color: particleColor
                                });
                                particles.push(currentParticle);
                                // Store initial data for saving the simulation
                                particleInitialData.push({
                                    x: currentParticle.initialX,
                                    y: currentParticle.initialY,
                                    baseOpacityTarget: currentParticle.targetOpacity,
                                    color: currentParticle.color,
                                    vx: currentParticle.vx,
                                    vy: currentParticle.vy,
                                    size: currentParticle.size,
                                    initialLife: currentParticle.initialLife,
                                });
                            }
                        }
                    }
                }
                statusMessage.textContent = isFullscreen ? `Sim complete: ${particles.length} particles. 'Esc' or Back to exit.` : `Sim complete: ${particles.length} particles.`;
                if (particles.length === 0 && (canvasWidth > 0 && canvasHeight > 0)) {
                     statusMessage.textContent += " No distinct cloud-like areas found.";
                }
                saveSimButton.disabled = particleInitialData.length === 0; // Enable save if particles were created

            } catch (e) {
                console.error("Error processing image data:", e);
                statusMessage.textContent = "Error: Could not process image data.";
                 saveSimButton.disabled = true;
            } finally {
                if (!isFullscreen) processButton.disabled = false; // Re-enable button if not in fullscreen
            }
        }

        // Main animation loop
        function animate() {
            ctx.clearRect(0, 0, particleCanvas.width, particleCanvas.height); // Clear canvas
            particles = particles.filter(p => p.life > 0); // Remove dead particles

            // Update and draw each particle
            particles.forEach(particle => {
                particle.update();
                particle.draw();
            });
            animationFrameId = requestAnimationFrame(animate); // Request next frame
        }

        // Function to generate HTML content for a standalone simulation file
        function generateSimulationHTML(pData, canvasW, canvasH, simTitle) {
            const particleClassString = Particle.toString(); // Get the Particle class code as a string

            // Stringify particle data, ensuring only necessary properties are included
            const pDataString = JSON.stringify(pData.map(p => ({
                x: p.x,
                y: p.y,
                baseOpacityTarget: p.baseOpacityTarget,
                color: p.color,
                vx: p.vx,
                vy: p.vy,
                size: p.size,
                initialLife: p.initialLife
            })));

            // Return the HTML template string
            return `
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>${simTitle} - Cloud Simulation</title>
    <style>
        body { margin: 0; background-color: #000026; overflow: hidden; display: flex; justify-content: center; align-items: center; min-height: 100vh; }
        canvas { display: block; background-color: #000026; }
    </style>
</head>
<body>
    <canvas id="simCanvas"></canvas>
    <script>
        const PARTICLE_COLORS = { CLOUD: '255, 255, 255', OVERSHOOT: '255, 165, 0' };
        (${particleClassString})(); // Reconstruct the Particle class in the saved file

        const canvas = document.getElementById('simCanvas');
        const ctx = canvas.getContext('2d');
        canvas.width = ${canvasW};
        canvas.height = ${canvasH};

        let particles = [];
        const particleInitialData = ${pDataString}; // Embed particle data

        // Create particles from the embedded data
        particleInitialData.forEach(params => {
            particles.push(new Particle(params));
        });

        // Animation loop for the saved simulation
        function animateSim() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            particles = particles.filter(p => p.life > 0);
            particles.forEach(p => { p.update(); p.draw(); });
            requestAnimationFrame(animateSim);
        }
        if (particles.length > 0) animateSim(); // Start animation if particles exist
    <\/script>
</body>
</html>`;
        }

        // Event listener for the "Save Simulation" button
        saveSimButton.addEventListener('click', () => {
            if (particleInitialData.length === 0) {
                alert("No simulation data to save.");
                return;
            }
            // Sanitize image name for use as file name
            const simTitle = sourceImageName.replace(/[^a-z0-9]/gi, '_').toLowerCase() || 'cloud_simulation';
            const htmlContent = generateSimulationHTML(particleInitialData, particleCanvas.width, particleCanvas.height, simTitle);

            // Create a Blob and trigger download
            const blob = new Blob([htmlContent], { type: 'text/html' });
            const link = document.createElement('a');
            link.href = URL.createObjectURL(blob);
            link.download = `${simTitle}.html`;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            URL.revokeObjectURL(link.href); // Clean up object URL
            statusMessage.textContent = "Simulation HTML generated for download.";
        });

        // Event listener for file input change
        imageFileInput.addEventListener('change', (event) => {
            const file = event.target.files[0];
            if (file) {
                sourceImageName = file.name; // Store file name
                fileNameDisplay.textContent = file.name;
                statusMessage.textContent = 'Image selected. Ready to simulate.';
                processButton.disabled = false; // Enable process button
                saveSimButton.style.display = 'none'; // Hide save button
                saveSimButton.disabled = true;
                if (isFullscreen) exitFullscreenMode(); // Exit fullscreen if active

                // Clear previous simulation
                if (animationFrameId) cancelAnimationFrame(animationFrameId);
                particles = []; particleInitialData = [];
                if (particleCanvas.width > 0 && particleCanvas.height > 0) {
                    ctx.clearRect(0, 0, particleCanvas.width, particleCanvas.height);
                }
            } else { // No file selected
                sourceImageName = 'simulation';
                fileNameDisplay.textContent = 'No file selected.';
                processButton.disabled = true;
                saveSimButton.style.display = 'none';
                statusMessage.textContent = '';
            }
        });

        // Event listener for the "Simulate Clouds" button
        processButton.addEventListener('click', () => {
            const file = imageFileInput.files[0];
            if (!file) { statusMessage.textContent = "Please select an image file first."; return; }
            statusMessage.textContent = "Preparing image...";
            processButton.disabled = true;

            sourceImage = new Image();
            sourceImage.onload = () => { // Image loaded successfully
                if (animationFrameId) cancelAnimationFrame(animationFrameId); // Stop previous animation
                enterFullscreenMode(); // Go to fullscreen
                analyzeImage(sourceImage); // Process the image
                if (particles.length > 0) {
                    animate(); // Start animation if particles were created
                } else if (isFullscreen) { // No particles, still in fullscreen
                     statusMessage.textContent = "No cloud-like areas found. 'Esc' or Back to exit.";
                } else { // No particles, not in fullscreen
                     processButton.disabled = false;
                }
                // Update save button state
                saveSimButton.style.display = particleInitialData.length > 0 ? 'inline-block' : 'none';
                saveSimButton.disabled = particleInitialData.length === 0;
            };
            sourceImage.onerror = () => { // Error loading image
                console.error("Error processing selected file as image.");
                statusMessage.textContent = "Error: Could not load selected file as image.";
                processButton.disabled = false;
                saveSimButton.style.display = 'none';
                if (isFullscreen) exitFullscreenMode();
            };
            // Read the file as a Data URL
            const reader = new FileReader();
            reader.onload = (e) => { sourceImage.src = e.target.result; }
            reader.readAsDataURL(file);
        });

        // Event listeners for exiting fullscreen
        backButton.addEventListener('click', exitFullscreenMode);
        window.addEventListener('keydown', (e) => { if (e.key === 'Escape' && isFullscreen) exitFullscreenMode(); });

        // Event listener for window resize (handles fullscreen canvas resize)
        window.addEventListener('resize', () => {
            if (isFullscreen) {
                const oldWidth = particleCanvas.width;
                const oldHeight = particleCanvas.height;
                particleCanvas.width = window.innerWidth;
                particleCanvas.height = window.innerHeight;

                // Scale particle positions if canvas was already drawn
                if (oldWidth > 0 && oldHeight > 0) { // Prevent division by zero
                    const scaleX = particleCanvas.width / oldWidth;
                    const scaleY = particleCanvas.height / oldHeight;
                    particles.forEach(p => {
                        p.x *= scaleX;
                        p.y *= scaleY;
                    });
                    // Also scale initial data for consistency if re-saved
                    particleInitialData.forEach(p => {
                        p.x *= scaleX;
                        p.y *= scaleY;
                    });
                }
                statusMessage.textContent = "Resized. 'Esc' or Back to exit.";
            }
        });

        // Set initial canvas size
        const defaultCanvasWidth = Math.min(window.innerWidth * 0.9, 700);
        const defaultCanvasHeight = Math.min(window.innerHeight * 0.4, 350);
        particleCanvas.width = defaultCanvasWidth;
        particleCanvas.height = defaultCanvasHeight;
        originalCanvasWidth = defaultCanvasWidth; // Store these as the non-fullscreen defaults
        originalCanvasHeight = defaultCanvasHeight;
        statusMessage.textContent = 'Select an image and click "Simulate Clouds".';

    </script>
</body>
</html>
